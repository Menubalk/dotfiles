# macOS
# .functions


###########################
### Directories & Files ###
###########################

# `o` with no arguments opens the current directory, otherwise opens the given
# location
o() {
  if [ ${#} -eq 0 ]; then
    open .
  else
    open "${@}"
  fi;
}

# Create a new directory and enter it
mkedir() {
  mkdir -p "${@}" && cd "${_}"
}

# Open Finder working directory in shell
# Short for `cdfinder`
cdf() {
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}

# Open shell working directory in Finder
fcd() {
  open . -R
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
targz() {
  local Tmpfile="${@%/}.tar"
  tar -cvf "${Tmpfile}" --exclude=".DS_Store" "${@}" || return 1

  Size=$(
    stat -f"%z" "${Tmpfile}" 2>/dev/null # macOS `stat`
    #stat -c"%s" "${Tmpfile}" 2>/dev/null # GNU `stat`
  );

  local Cmd="";
  if (( ${Size} < 52428800 )) && hash zopfli 2>/dev/null; then
    # the .tar file is smaller than 50 MB and Zopfli is available; use it
    Cmd="zopfli"
  else
    if hash pigz 2>/dev/null; then
      Cmd="pigz"
    else
      Cmd="gzip"
    fi;
  fi;

  printf "Compressing .tar ($((size / 1000)) kB) using \`${Cmd}\`…\n"
  "${Cmd}" -v "${Tmpfile}" || return 1
  [ -f "${Tmpfile}" ] && rm "${Tmpfile}"

  Zippedsize=$(
    stat -f"%z" "${Tmpfile}.gz" 2>/dev/null; # macOS `stat`
    #stat -c"%s" "${Tmpfile}.gz" 2>/dev/null; # GNU `stat`
  );

  printf "${Tmpfile}.gz ($((Zippedsize / 1000)) kB) created successfully.\n"
}

# Compare original and gzipped file size
gzcompare() {
  local Origsize=$(wc -c < "${1}")
  local Gzipsize=$(gzip -c "${1}" | wc -c)
  local Ratio=$(printf "${Gzipsize} * 100 / ${Origsize}\n" | bc -l)
  printf "orig: %d bytes\n" "${Origsize}"
  printf "gzip: %d bytes (%2.2f%%)\n" "${Gzipsize}" "${Ratio}"
}

# Determine size of a file or total size of a directory
size() {
  if du -b /dev/null >/dev/null 2>&1; then
    local Arg=-sbh
  else
    local Arg=-sh
  fi;
  if [ -n "${1}" ]; then
    du ${Arg} -- "${1}"
  else
    du ${Arg} .[^.]* ./*
  fi;
}

# Use Git’s colored diff when available
if hash git >/dev/null 2>&1; then
  diff() {
    git diff --no-index --color-words "${@}"
  }
fi;

# `trees` is `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
trees() {
  tree -aC -I '.git | node_modules | bower_components' --dirsfirst "${@}" | less -FRNX
}



###################
### Text & URLs ###
###################

# Launch a DuckDuckGo search from the shell
# `ddg 'fruity loops' or `ddg 'fruity loops' youtube` or `ddg 'fruity loops' yt`
ddg() {
  if [ ${#} -gt 1 ]; then
    open "https://duckduckgo.com/?q=${1}"
  elif [ ${#} -gt 2 ]; then
    open "https://duckduckgo.com/?q=${1}\!${2}"
  else
    printf "Invalid input!\n"
  fi;
}

# Shorten URLs via Tinyurl
# Other shorteners all require CAPTCHA, API key or OAuth
tinyurl() {
  local Url="$(pbpaste)"
  local Tinyurl=$(curl -s "http://tinyurl.com/api-create.php?url=${Url}")
  printf "${Tinyurl}" | pbcopy
  printf "${Tinyurl} copied to clipboard!\n"
}

# Create a git.io short URL
gitio() {
  if [ -z "${1}" -o -z "${2}" ]; then
    printf "Usage: \`gitio urlname url\`\n"
    return 1
  fi;
  curl -s -i "https://git.io/" -F "url=${2}" -F "code=${1}" | grep --color=never "Location"
}

# Paste code online via PasteOfCode.org
# Takes either clipboard or file as input
# Example: `poc cpp` or `poc "cpp ~/project/test_c++_project.cpp"`
# Full language list: git.io/poclanguages
poc() {
  if [ ${#} -eq 1 ]; then
    if [ ! -z "$(pbpaste)" ]; then
      local Code="$(pbpaste)"
    else
      printf "Your clipboard is empty!"
      return 1
    fi;
  elif [ ${#} -eq 2 ]; then
    if [ -f "${2}" ]; then
      local Code="$(cat "${2}" 2>/dev/null)"
    else
      printf "Wrong filepath!\n"
      return 1
    fi;
  else
    printf "Too many paramaters!\n"
    return 1
  fi;
  local Language="${1}"
  local Pastelink="$(curl -s -L --form-string code="${Code}" \
    --form-string language="${Language}" --form-string notabot="most_likely" \
    -w "%{url_effective}\n" "https://paste.ofcode.org/" -o /dev/null)"
  if [ "${Pastelink}" = "https://paste.ofcode.org/" ]; then
    printf "Invalid code or language!\n"
    return 1
  fi;
  printf '%s' "${Pastelink}" | pbcopy
  printf '%s\n' "${Pastelink} copied to clipboard!"
}

# Create a data URL from a file
dataurl() {
  local mimeType=$(file -b --mime-type "${1}")
  if [ "${mimeType}" = "text/"* ]; then
    mimeType="${mimeType};charset=utf-8"
  fi;
  printf "data:${mimeType};base64,$(openssl base64 -in "${1}" | tr -d '\n')\n"
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
json() {
  if [ -t 0 ]; then # argument
    python -mjson.tool <<< "$*" | pygmentize -l javascript
  else # pipe
    python -mjson.tool | pygmentize -l javascript
  fi;
}

# Encode a Unicode character to its escape sequence
uce() {
  printf "\\\x%s" $(printf "${1}" | xxd -p -c1 -u)
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    printf "\n"
  fi;
}

# Decode a Unicode escape sequence to its character
ucd() {
  perl -e "binmode(STDOUT, ':utf8'); print \"${1}\"";
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    printf "\n"
  fi;
}

# Get a character its Unicode code point
ucp() {
  perl -e "use utf8; print sprintf('U+%04X', ord(\"${1}\"))";
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    printf "\n"
  fi;
}

# `s` with no arguments opens the current directory in Sublime Text, otherwise
# opens the given location
s() {
  if [ ${#} -eq 0 ]; then
    subl .
  else
    subl "${@}"
  fi;
}

# `v` with no arguments opens the current directory in Vim, otherwise opens the
# given location
v() {
  if [ ${#} -eq 0 ]; then
    vim .
  else
    vim "${@}"
  fi;
}

# `c` with no arguments opens the current directory in Visual Studio Code
# otherwise opens the given location
c() {
  if [ ${#} -eq 0 ]; then
    code .
  else
    code "${@}"
  fi;
}

# `a` with no arguments opens the current directory in Atom, otherwise
# opens the given location
a() {
  if [ ${#} -eq 0 ]; then
    atom .
  else
    atom "${@}"
  fi;
}



#########################
### System & Packages ###
#########################

# Get updates for macOS, Homebrew, NPM, Ruby and their respective packages
updateall() {
  printf "Updating packages: "
  printf "macOS "
  ( sudo softwareupdate -i -a ) >/dev/null 2>&1
  printf "Homebrew "
  ( brew update && brew upgrade && brew cleanup ) >/dev/null 2>&1
  printf "Node "
  ( npm install npm@latest -g && npm update -g && npm cache clean --force ) >/dev/null 2>&1
  printf "Ruby "
  ( sudo gem update --system && sudo gem update && sudo gem cleanup ) >/dev/null 2>&1
  printf "done!\n"
}

# Easy volume manipulation
vol() {
  osascript \
  -e 'on run(argv)' \
    -e 'set volume output volume (item 1 of argv)' \
  -e 'end run' "${1}"
}

# For Linux
#vol() {
#  pactl set-sink-volume 0 "${1}%"
#}

# Add public SSH key from machine to remote
# Example: `ssh-copy-id username server`
ssh-cp-id() {
  cat "${HOME}/.ssh/id_rsa.pub" | \
  ssh -o PreferredAuthentications=password -o ConnectTimeout=5 "${1}@${2}" \
  'mkdir "${HOME}/.ssh" 2>/dev/null; cat >> "${HOME}/.ssh/authorized_keys"'
}

# Reboot WRT routers from the shell
# Only works if your SSH pubkey has been added to the router
rbwrt() {
  for IP in ${@}; do
    ssh -o PreferredAuthentications=publickey -o ConnectTimeout=5 \
    "root@${IP}" 'reboot'
  done;
}

# Supercleaner
# http://tinyurl.com/bksb7br
emptyall() {
  # Empty the Trash on all mounted volumes
  sudo rm -Rfv /Volumes/*/.Trashes
  sudo rm -Rfv "${HOME}/.Trash"
  # Clear Apple’s System Logs to improve shell startup speed
  sudo rm -Rfv /private/var/log/asl/*.asl
  # Clear download history from quarantine
  sqlite3 ${HOME}/Library/Preferences/com.apple.LaunchServices.QuarantineEventsV* \
  'delete from LSQuarantineEvent'
}

# Delete all '.DS_Store' files
# Resets folder-specific UI preferences
ds_clean() {
  sudo find / -name ".DS_Store" -depth -exec rm {} \;
}

# Clean up duplicate 'open with' entries
ls_clean() {
  /System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister -kill -r -domain local -domain system -domain user
}

lockscr() {
  if [ "$(defaults read com.apple.screensaver askForPasswordDelay 2>/dev/null)" ]; then
    local Olddelay="$(defaults read com.apple.screensaver askForPasswordDelay)"
    defaults write com.apple.screensaver askForPasswordDelay -int 0 && \
    pmset displaysleepnow
    printf "Screen locked!\n"
    defaults write com.apple.screensaver askForPasswordDelay -int "${Olddelay}"
  else
    defaults write com.apple.screensaver askForPasswordDelay -int 0 && \
    pmset displaysleepnow
    printf "Screen locked!\n"
    defaults delete com.apple.screensaver askForPasswordDelay
  fi;
}

# Fix `Address Book` wakelock
fixab() {
  ( pmset -g | grep "AddressBookSourceSync" && \
  setopt rmstarsilent # `rmstarsilent` prevents zsh nagging
  rm -Rf "${HOME}/Library/Caches/com.apple.AddressBookSourceSync/"* && \
  rm -Rf "${HOME}/Library/Application Support/AddressBook/"* && \
  unsetopt rmstarsilent # but it's a nice safety feature
  killall "AddressBookSourceSync" ) >/dev/null 2>&1 && \
  printf "Address Book wakelock fixed!\n" || printf "Fixing Address Book wakelock failed!\n"
}

# Get an application its bundle identifier (com.apple.keychainaccess)
# Usage: `bundleid "Keychain Access"`
bundleid() {
  # Conditional is needed because non-existing apps will otherwise cause 'where is App located?' popups
  if [ "$(find -L "/Applications" -maxdepth 3 -type d -name "${1}.app" -print -quit)" ] \
  || [ "$(find -L "/System/Library/CoreServices" -maxdepth 2 -type d -name "${1}.app" -print -quit)" ]; then
    osascript \
      -e 'on run(argv)' \
        -e 'id of application (item 1 of argv)' \
      -e 'end run' "${1}"
  else
    printf "Application '${1}' could not be located!\n"
  fi;
}

# Make bootable USB
# Usage: `mkusb ~/Downloads/fedora.iso disk2`
#mkusb() {
#  # Unmount disk if still mounted
#  if [ "$(mount | grep "${2}")" ]; then umount -f ${2}; fi;
#  # Use OS-compatible 'bs'
#  if [ "$(uname)" = "Linux" ]; then bs=1M; else bs=1m; fi;
#  sudo dd if="${1}" of="/dev/r${2}" bs=${bs}
#}

# Set firmware password
# Usage: 'fwpwd'
fwpwd() {
  # Mount recovery disk
  diskutil mount "Recovery HD" 1>/dev/null && wait
  hdiutil attach -quiet -nobrowse "/Volumes/Recovery HD/com.apple.recovery.boot/BaseSystem.dmg" && wait
  # Ask for new firmware password
  printf "Please enter new firmware password..\n"
  printf "Password:" && read -s Newpassword && printf "\n"
  printf "Confirm new firmware password..\n"
  printf "Password:" && read -s Confirmpassword && printf "\n"
  if [ ! "${Newpassword}" = "${Confirmpassword}" ]; then
    printf "Entered passwords don't match!\n"
  fi;
  # Ask for admin password up front
  if [ ! "${UID}" = 0 ]; then
    printf "Please enter your user password..\n"
    sudo -v
  fi;
  # Set firmware password
  sudo "/Volumes/OS X Base System/Applications/Utilities/Firmware Password Utility.app/Contents/Resources/setregproptool" -m "command" -p "${Confirmpassword}"
  # Unmount recovery disk
  diskutil unmount force "Recovery HD" 1>/dev/null && wait
  printf "New firmware password set!\n"
}



##########################
### Browsers & servers ###
##########################

# Use Chrome from shell
chrome() {
  # Prevent shell from foregrounding `chrome`
  if ! pgrep "Chrome" >/dev/null 2>&1; then
    open -a "Google Chrome" >/dev/null 2>&1 && \
    osascript -e 'tell app "Google Chrome" to close front window'
  fi;
  # Open Chrome binary with arguments, then switch to created window
  "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" ${@} 2>/dev/null \
  && open -a "Google Chrome" >/dev/null 2>&1
}

# Kill all the tabs in Chrome to free up memory
# `grep [C]hrome` explained: tinyurl.com/c7uq9x
ctabkill() {
  ps ux | grep '[C]hrome Helper --type=renderer' | grep -v extension-process |\
  tr -s ' ' | cut -d ' ' -f2 | xargs kill
}

# Open all Safari tabs in Chrome
tabsaco() {
  open -a "Google Chrome"
  osascript \
  -e 'tell application "Chrome" to activate' \
  -e 'set list_Tabs to {}' \
  -e 'tell application "Safari"' \
    -e 'set the_Tabs to (tabs of every window)' \
    -e 'repeat with the_Tab in the_Tabs' \
      -e 'set the_Items to (every item of the_Tab)' \
      -e 'repeat with the_Item in the_Items' \
        -e 'copy URL of the_Item to end of list_Tabs' \
      -e 'end repeat' \
    -e 'end repeat' \
  -e 'end tell' \
  -e 'tell application "Google Chrome"' \
    -e 'repeat with list_Tab in list_Tabs' \
      -e 'set myTab to make new tab at end of tabs of window 1' \
      -e 'set URL of myTab to list_Tab' \
    -e 'end repeat' \
  -e 'end tell' \
  -e 'tell application "System Events" to set visible of process "Safari" to false'
}

# Open all Chrome tabs in Safari
tabcosa() {
  open -a "Safari"
  osascript \
  -e 'set list_Tabs to {}' \
  -e 'tell application "Google Chrome"' \
    -e 'set the_Tabs to (tabs of every window)' \
    -e 'repeat with the_Tab in the_Tabs' \
      -e 'set the_Items to (every item of the_Tab)' \
      -e 'repeat with the_Item in the_Items' \
        -e 'copy URL of the_Item to end of list_Tabs' \
      -e 'end repeat' \
    -e 'end repeat' \
  -e 'end tell' \
  -e 'tell application "Safari"' \
    -e 'repeat with list_Tab in list_Tabs' \
      -e 'set myTab to make new tab at end of tabs of window 1' \
      -e 'set URL of myTab to list_Tab' \
    -e 'end repeat' \
  -e 'end tell' \
  -e 'tell application "System Events" to set visible of process "Google Chrome" to false'
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
phpserver() {
  local port="${1:-4000}"
  local ip=$(ipconfig getifaddr en0)
  sleep 1 && open "http://${ip}:${port}/" &
  php -S "${ip}:${port}"
}

# Start an HTTP server from a directory, optionally specifying the port
httpserver() {
  local port="${1:-8000}"
  sleep 1 && open "http://localhost:${port}/" &
  # Set the default Content-Type to `text/plain` instead
  # of `application/octet-stream`, and serve everything as UTF-8
  # While technically incorrect, it doesn’t break anything for binary files
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\n\map[""] = "text/plain";\nfor key, value in map.items():\n\t\map[key] = value + ";charset=UTF-8";\n\SimpleHTTPServer.test();' "$port";
}

# View HTTP traffic
httpsniff() {
  if hash "ngrep" 2>/dev/null; then
    sudo ngrep -d 'en0' -t '^(GET|POST) ' 'tcp and port 80'
  else
    printf "'ngrep' not available!\n"
  fi;
}

# Dump HTTP traffic
httpdump() {
  sudo tcpdump -i en0 -n -s 0 -w - | grep -a -o -E \"Host\: .*|GET \/.*\"
}

# Dump Wi-Fi traffic
# `wifidump 6` to dump channel 6
wifidump() {
  local airport="/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
  while [ "${#}" -gt 0 ]; do
  # Check if first argument is an option
    case "${1}" in
    -s|--stop)
      kill "${wifidumpPID}"
      break
    ;;
    -*)
      printf "Invalid option: ${1}\n"
      return 1
    ;;
    *)
    ( sudo "${airport}" "en0" sniff "${1}" ) &
    wifidumpPID="${!}"
    ;;
    esac
  shift
  done
}
