# macOS
# .functions

# Create a new directory and enter it
mkedir() {
  mkdir -p "${@}" && cd "${_}"
}

# Change working directory to the top-most Finder window location
# Short for `cdfinder`
cdf() {
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
targz() {
  local Tmpfile="${@%/}.tar"
  tar -cvf "${Tmpfile}" --exclude=".DS_Store" "${@}" || return 1

  Size=$(
    stat -f"%z" "${Tmpfile}" 2>/dev/null # macOS `stat`
    stat -c"%s" "${Tmpfile}" 2>/dev/null # GNU `stat`
  );

  local cmd="";
  if (( ${Size} < 52428800 )) && hash zopfli 2>/dev/null; then
    # the .tar file is smaller than 50 MB and Zopfli is available; use it
    cmd="zopfli"
  else
    if hash pigz 2>/dev/null; then
      cmd="pigz"
    else
      cmd="gzip"
    fi;
  fi;

  printf "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…\n"
  "${cmd}" -v "${Tmpfile}" || return 1
  [ -f "${Tmpfile}" ] && rm "${Tmpfile}"

  zippedSize=$(
    stat -f"%z" "${Tmpfile}.gz" 2>/dev/null; # macOS `stat`
    stat -c"%s" "${Tmpfile}.gz" 2>/dev/null; # GNU `stat`
  );

  printf "${Tmpfile}.gz ($((zippedSize / 1000)) kB) created successfully.\n"
}

# Compare original and gzipped file size
gzcompare() {
  local origsize=$(wc -c < "${1}")
  local gzipsize=$(gzip -c "${1}" | wc -c)
  local ratio=$(printf "${gzipsize} * 100 / ${origsize}\n" | bc -l)
  printf "orig: %d bytes\n" "${origsize}"
  printf "gzip: %d bytes (%2.2f%%)\n" "${gzipsize}" "${ratio}"
}

# Determine size of a file or total size of a directory
size() {
  if du -b /dev/null >/dev/null 2>&1; then
    local arg=-sbh
  else
    local arg=-sh
  fi;
  if [ -n "${1}" ]; then
    du ${arg} -- "${1}"
  else
    du ${arg} .[^.]* ./*
  fi;
}

# Use Git’s colored diff when available
hash git >/dev/null 2>&1;
if [ $? -eq 0 ]; then
  diff() {
    git diff --no-index --color-words "${@}"
  }
fi;

# Create a data URL from a file
dataurl() {
  local mimeType=$(file -b --mime-type "${1}")
  if [ "${mimeType}" = "text/"* ]; then
    mimeType="${mimeType};charset=utf-8"
  fi;
  printf "data:${mimeType};base64,$(openssl base64 -in "${1}" | tr -d '\n')\n"
}

# Create a git.io short URL
gitio() {
  if [ -z "${1}" -o -z "${2}" ]; then
    printf "Usage: \`gitio slug url\`\n"
    return 1
  fi;
  curl -i https://git.io/ -F "url=${2}" -F "code=${1}"
}

# Start an HTTP server from a directory, optionally specifying the port
httpserver() {
  local port="${1:-8000}"
  sleep 1 && open "http://localhost:${port}/" &
  # Set the default Content-Type to `text/plain` instead
  # of `application/octet-stream`
  # And serve everything as UTF-8
  # While not technically correct, it doesn’t break anything for binary files
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\n\map[""] = "text/plain";\nfor key, value in map.items():\n\t\map[key] = value + ";charset=UTF-8";\n\SimpleHTTPServer.test();' "$port";
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
phpserver() {
  local port="${1:-4000}"
  local ip=$(ipconfig getifaddr en1)
  sleep 1 && open "http://${ip}:${port}/" &
  php -S "${ip}:${port}"
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
json() {
  if [ -t 0 ]; then # argument
    python -mjson.tool <<< "$*" | pygmentize -l javascript
  else # pipe
    python -mjson.tool | pygmentize -l javascript
  fi;
}

# Encode a Unicode character to its escape sequence
uce() {
  printf "\\\x%s" $(printf "${1}" | xxd -p -c1 -u)
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    printf "\n"
  fi;
}

# Decode a Unicode escape sequence to its character
ucd() {
  perl -e "binmode(STDOUT, ':utf8'); print \"${1}\"";
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    printf "\n"
  fi;
}

# Get a character its Unicode code point
ucp() {
  perl -e "use utf8; print sprintf('U+%04X', ord(\"${1}\"))";
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    printf "\n"
  fi;
}

# `s` with no arguments opens the current directory in Sublime Text, otherwise
# opens the given location
s() {
  if [ $# -eq 0 ]; then
    subl .
  else
    subl "${@}"
  fi;
}

# `a` with no arguments opens the current directory in Atom Editor, otherwise
# opens the given location
a() {
  if [ $# -eq 0 ]; then
    atom .
  else
    atom "${@}"
  fi;
}

# `v` with no arguments opens the current directory in Vim, otherwise opens the
# given location
v() {
  if [ $# -eq 0 ]; then
    vim .
  else
    vim "${@}"
  fi;
}

# `c` with no arguments opens the current directory in Visual Studio Code
# otherwise opens the given location
c() {
  if [ $# -eq 0 ]; then
    code .
  else
    code "${@}"
  fi;
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location
o() {
  if [ $# -eq 0 ]; then
    open .
  else
    open "${@}"
  fi;
}

# `trees` is `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
trees() {
  tree -aC -I '.git | node_modules | bower_components' --dirsfirst "${@}" | less -FRNX
}

# Get updates for macOS, Homebrew, NPM, Ruby and their respective packages
update() {
  printf "Updated packages: "
  ( sudo softwareupdate -i -a ) >/dev/null 2>&1
  printf "macOS "
  ( brew update && brew upgrade && brew cleanup ) >/dev/null 2>&1
  printf "Homebrew "
  ( npm install npm@latest -g && npm update -g && npm cache clean --force ) >/dev/null 2>&1
  printf "Node "
  ( sudo gem update --system && sudo gem update && sudo gem cleanup ) >/dev/null 2>&1
  printf "Ruby\n"
}

# Easy volume manipulation
volume() {
  osascript \
  -e 'on run(argv)' \
    -e 'set volume output volume (item 1 of argv)' \
  -e 'end run' "${1}"
}

# Get bundle name of an application like 'com.apple.Safari'
# Example: bundleid "Keychain Access"
bundleid() {
  # Conditional is needed because non-existing apps will otherwise cause 'where is App located?' popups
  if [ "$(find -L "/Applications" -maxdepth 3 -type d -name "${1}.app" -print -quit)" ] \
  || [ "$(find -L "/System/Library/CoreServices" -maxdepth 2 -type d -name "${1}.app" -print -quit)" ]; then
    osascript \
      -e 'on run(argv)' \
        -e 'id of application (item 1 of argv)' \
      -e 'end run' "${1}"
  else
    printf "Application '${1}' could not be located!\n"
  fi;
}

# Shorten URLs via Tinyurl
# Other shorteners (goo.gl, bit.ly, ow.ly) all require API keys
tinyurl() {
  curl -s "http://tinyurl.com/api-create.php?url=${1}" | pbcopy
}

# Reboot WRT routers via the terminal
# Only works if your SSH key has been added to the router
rbWRT() {
  for IP in ${@}; do
    ssh -o ConnectTimeout=5 "root@${IP}" 'reboot'
  done;
}

# Open all Chrome tabs in Safari
tabcosa() {
  open -a "Safari"
  osascript \
  -e 'set list_Tabs to {}' \
  -e 'tell application "Google Chrome"' \
    -e 'set the_Tabs to (tabs of every window)' \
    -e 'repeat with the_Tab in the_Tabs' \
      -e 'set the_Items to (every item of the_Tab)' \
      -e 'repeat with the_Item in the_Items' \
        -e 'copy URL of the_Item to end of list_Tabs' \
      -e 'end repeat' \
    -e 'end repeat' \
  -e 'end tell' \
  -e 'tell application "Safari"' \
    -e 'repeat with list_Tab in list_Tabs' \
      -e 'set myTab to make new tab at end of tabs of window 1' \
      -e 'set URL of myTab to list_Tab' \
    -e 'end repeat' \
  -e 'end tell' \
  -e 'tell application "System Events" to set visible of process "Google Chrome" to false'
}

# Open all Safari tabs in Chrome
tabsaco() {
  open -a "Google Chrome"
  osascript \
  -e 'tell application "Chrome" to activate' \
  -e 'set list_Tabs to {}' \
  -e 'tell application "Safari"' \
    -e 'set the_Tabs to (tabs of every window)' \
    -e 'repeat with the_Tab in the_Tabs' \
      -e 'set the_Items to (every item of the_Tab)' \
      -e 'repeat with the_Item in the_Items' \
        -e 'copy URL of the_Item to end of list_Tabs' \
      -e 'end repeat' \
    -e 'end repeat' \
  -e 'end tell' \
  -e 'tell application "Google Chrome"' \
    -e 'repeat with list_Tab in list_Tabs' \
      -e 'set myTab to make new tab at end of tabs of window 1' \
      -e 'set URL of myTab to list_Tab' \
    -e 'end repeat' \
  -e 'end tell' \
  -e 'tell application "System Events" to set visible of process "Safari" to false'
}
