# macOS
# .functions

# Create a new directory and enter it
mkedir() {
  mkdir -p "${@}" && cd "${_}"
}

# Open Finder working directory in shell
# Short for `cdfinder`
cdf() {
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}

# Open shell working directory in Finder
fcd() {
  open . -R
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
targz() {
  local Tmpfile="${@%/}.tar"
  tar -cvf "${Tmpfile}" --exclude=".DS_Store" "${@}" || return 1

  Size=$(
    stat -f"%z" "${Tmpfile}" 2>/dev/null # macOS `stat`
    #stat -c"%s" "${Tmpfile}" 2>/dev/null # GNU `stat`
  );

  local Cmd="";
  if (( ${Size} < 52428800 )) && hash zopfli 2>/dev/null; then
    # the .tar file is smaller than 50 MB and Zopfli is available; use it
    Cmd="zopfli"
  else
    if hash pigz 2>/dev/null; then
      Cmd="pigz"
    else
      Cmd="gzip"
    fi;
  fi;

  printf "Compressing .tar ($((size / 1000)) kB) using \`${Cmd}\`…\n"
  "${Cmd}" -v "${Tmpfile}" || return 1
  [ -f "${Tmpfile}" ] && rm "${Tmpfile}"

  Zippedsize=$(
    stat -f"%z" "${Tmpfile}.gz" 2>/dev/null; # macOS `stat`
    #stat -c"%s" "${Tmpfile}.gz" 2>/dev/null; # GNU `stat`
  );

  printf "${Tmpfile}.gz ($((Zippedsize / 1000)) kB) created successfully.\n"
}

# Compare original and gzipped file size
gzcompare() {
  local Origsize=$(wc -c < "${1}")
  local Gzipsize=$(gzip -c "${1}" | wc -c)
  local Ratio=$(printf "${Gzipsize} * 100 / ${Origsize}\n" | bc -l)
  printf "orig: %d bytes\n" "${Origsize}"
  printf "gzip: %d bytes (%2.2f%%)\n" "${Gzipsize}" "${Ratio}"
}

# Determine size of a file or total size of a directory
size() {
  if du -b /dev/null >/dev/null 2>&1; then
    local Arg=-sbh
  else
    local Arg=-sh
  fi;
  if [ -n "${1}" ]; then
    du ${Arg} -- "${1}"
  else
    du ${Arg} .[^.]* ./*
  fi;
}

# Use Git’s colored diff when available
if hash git >/dev/null 2>&1; then
  diff() {
    git diff --no-index --color-words "${@}"
  }
fi;

# Create a data URL from a file
dataurl() {
  local mimeType=$(file -b --mime-type "${1}")
  if [ "${mimeType}" = "text/"* ]; then
    mimeType="${mimeType};charset=utf-8"
  fi;
  printf "data:${mimeType};base64,$(openssl base64 -in "${1}" | tr -d '\n')\n"
}

# Create a git.io short URL
gitio() {
  if [ -z "${1}" -o -z "${2}" ]; then
    printf "Usage: \`gitio urlname url\`\n"
    return 1
  fi;
  curl -s -i https://git.io/ -F "url=${2}" -F "code=${1}" | grep --color=never "Location"
}

# Start an HTTP server from a directory, optionally specifying the port
httpserver() {
  local port="${1:-8000}"
  sleep 1 && open "http://localhost:${port}/" &
  # Set the default Content-Type to `text/plain` instead
  # of `application/octet-stream`
  # And serve everything as UTF-8
  # While not technically correct, it doesn’t break anything for binary files
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\n\map[""] = "text/plain";\nfor key, value in map.items():\n\t\map[key] = value + ";charset=UTF-8";\n\SimpleHTTPServer.test();' "$port";
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
phpserver() {
  local port="${1:-4000}"
  local ip=$(ipconfig getifaddr en1)
  sleep 1 && open "http://${ip}:${port}/" &
  php -S "${ip}:${port}"
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
json() {
  if [ -t 0 ]; then # argument
    python -mjson.tool <<< "$*" | pygmentize -l javascript
  else # pipe
    python -mjson.tool | pygmentize -l javascript
  fi;
}

# Encode a Unicode character to its escape sequence
uce() {
  printf "\\\x%s" $(printf "${1}" | xxd -p -c1 -u)
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    printf "\n"
  fi;
}

# Decode a Unicode escape sequence to its character
ucd() {
  perl -e "binmode(STDOUT, ':utf8'); print \"${1}\"";
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    printf "\n"
  fi;
}

# Get a character its Unicode code point
ucp() {
  perl -e "use utf8; print sprintf('U+%04X', ord(\"${1}\"))";
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    printf "\n"
  fi;
}

# `s` with no arguments opens the current directory in Sublime Text, otherwise
# opens the given location
s() {
  if [ $# -eq 0 ]; then
    subl .
  else
    subl "${@}"
  fi;
}

# `a` with no arguments opens the current directory in Atom Editor, otherwise
# opens the given location
a() {
  if [ $# -eq 0 ]; then
    atom .
  else
    atom "${@}"
  fi;
}

# `v` with no arguments opens the current directory in Vim, otherwise opens the
# given location
v() {
  if [ $# -eq 0 ]; then
    vim .
  else
    vim "${@}"
  fi;
}

# `c` with no arguments opens the current directory in Visual Studio Code
# otherwise opens the given location
c() {
  if [ $# -eq 0 ]; then
    code .
  else
    code "${@}"
  fi;
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location
o() {
  if [ $# -eq 0 ]; then
    open .
  else
    open "${@}"
  fi;
}

# `trees` is `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
trees() {
  tree -aC -I '.git | node_modules | bower_components' --dirsfirst "${@}" | less -FRNX
}

# Get updates for macOS, Homebrew, NPM, Ruby and their respective packages
update() {
  printf "Updating packages: "
  printf "macOS "
  ( sudo softwareupdate -i -a ) >/dev/null 2>&1
  printf "Homebrew "
  ( brew update && brew upgrade && brew cleanup ) >/dev/null 2>&1
  printf "Node "
  ( npm install npm@latest -g && npm update -g && npm cache clean --force ) >/dev/null 2>&1
  printf "Ruby "
  ( sudo gem update --system && sudo gem update && sudo gem cleanup ) >/dev/null 2>&1
  printf "done!\n"
}

# Easy volume manipulation
volume() {
  osascript \
  -e 'on run(argv)' \
    -e 'set volume output volume (item 1 of argv)' \
  -e 'end run' "${1}"
}

# Get an application its bundle identifier (com.apple.keychainaccess)
# e.g. bundleid "Keychain Access"
bundleid() {
  # Conditional is needed because non-existing apps will otherwise cause 'where is App located?' popups
  if [ "$(find -L "/Applications" -maxdepth 3 -type d -name "${1}.app" -print -quit)" ] \
  || [ "$(find -L "/System/Library/CoreServices" -maxdepth 2 -type d -name "${1}.app" -print -quit)" ]; then
    osascript \
      -e 'on run(argv)' \
        -e 'id of application (item 1 of argv)' \
      -e 'end run' "${1}"
  else
    printf "Application '${1}' could not be located!\n"
  fi;
}

# Shorten URLs via Tinyurl
# Other shorteners (goo.gl, bit.ly, ow.ly) all require API keys
tinyurl() {
  local Url="${1}"
  local Tinyurl=$(curl -s "http://tinyurl.com/api-create.php?url=${Url}")
  printf "${Tinyurl}" | pbcopy
  printf "${Tinyurl} copied to clipboard!\n"
}

# Reboot WRT routers from the shell
# Only works if your SSH key has been added to the router
rbwrt() {
  for IP in ${@}; do
    ssh -o ConnectTimeout=5 "root@${IP}" 'reboot'
  done;
}

# Fix `Address Book` wakelock
fixab() {
  ( pmset -g | grep "AddressBookSourceSync" && \
  setopt rmstarsilent # `rmstarsilent` prevents zsh nagging
  rm -Rf "${HOME}/Library/Caches/com.apple.AddressBookSourceSync/"* && \
  rm -Rf "${HOME}/Library/Application Support/AddressBook/"* && \
  unsetopt rmstarsilent # but it's a nice safety feature
  killall -0 "AddressBookSourceSync" ) >/dev/null 2>&1 && \
  printf "Address Book caches cleaned!\n"
}

# Supercleaner
# http://tinyurl.com/bksb7br
emptytrash() {
  # Empty the Trash on all mounted volumes
  sudo rm -Rfv /Volumes/*/.Trashes
  sudo rm -Rfv "${HOME}/.Trash"
  # Clear Apple’s System Logs to improve shell startup speed
  sudo rm -Rfv /private/var/log/asl/*.asl
  # Clear download history from quarantine
  sqlite3 ${HOME}/Library/Preferences/com.apple.LaunchServices.QuarantineEventsV* \
  'delete from LSQuarantineEvent'
}

# Use Chrome from shell
chrome() {
  # Prevents shell from foregrounding `chrome`
  if ! pgrep "Chrome" >/dev/null 2>&1; then
    open -a "Google Chrome" >/dev/null 2>&1 && \
    osascript -e 'tell app "Google Chrome" to close front window'
  fi;
  # Open Chrome binary with arguments, then switch to created window
  "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" ${@} 2>/dev/null \
  && open -a "Google Chrome" >/dev/null 2>&1
}

# Kill all the tabs in Chrome to free up memory
# `grep [C]hrome` explained: tinyurl.com/c7uq9x
ctabkill() {
  ps ux | grep '[C]hrome Helper --type=renderer' | grep -v extension-process |\
  tr -s ' ' | cut -d ' ' -f2 | xargs kill
}

# Open all Safari tabs in Chrome
tabsaco() {
  open -a "Google Chrome"
  osascript \
  -e 'tell application "Chrome" to activate' \
  -e 'set list_Tabs to {}' \
  -e 'tell application "Safari"' \
    -e 'set the_Tabs to (tabs of every window)' \
    -e 'repeat with the_Tab in the_Tabs' \
      -e 'set the_Items to (every item of the_Tab)' \
      -e 'repeat with the_Item in the_Items' \
        -e 'copy URL of the_Item to end of list_Tabs' \
      -e 'end repeat' \
    -e 'end repeat' \
  -e 'end tell' \
  -e 'tell application "Google Chrome"' \
    -e 'repeat with list_Tab in list_Tabs' \
      -e 'set myTab to make new tab at end of tabs of window 1' \
      -e 'set URL of myTab to list_Tab' \
    -e 'end repeat' \
  -e 'end tell' \
  -e 'tell application "System Events" to set visible of process "Safari" to false'
}

# Open all Chrome tabs in Safari
tabcosa() {
  open -a "Safari"
  osascript \
  -e 'set list_Tabs to {}' \
  -e 'tell application "Google Chrome"' \
    -e 'set the_Tabs to (tabs of every window)' \
    -e 'repeat with the_Tab in the_Tabs' \
      -e 'set the_Items to (every item of the_Tab)' \
      -e 'repeat with the_Item in the_Items' \
        -e 'copy URL of the_Item to end of list_Tabs' \
      -e 'end repeat' \
    -e 'end repeat' \
  -e 'end tell' \
  -e 'tell application "Safari"' \
    -e 'repeat with list_Tab in list_Tabs' \
      -e 'set myTab to make new tab at end of tabs of window 1' \
      -e 'set URL of myTab to list_Tab' \
    -e 'end repeat' \
  -e 'end tell' \
  -e 'tell application "System Events" to set visible of process "Google Chrome" to false'
}
